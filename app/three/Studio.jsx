/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 studio.glb -d -k 
*/
"use client";

import React, { useState, useRef, useEffect } from "react";
import * as THREE from "three";
import { useGLTF } from "@react-three/drei";
import { useLoader, useFrame, useThree } from "@react-three/fiber";
import { useControls } from "leva";
import { BlendFunction } from "postprocessing";
import { Select, Selection } from "@react-three/postprocessing";

import Effects from "./Effects";
import vertexShader from "./shaders/studio/vertexShader.glsl";
import fragmentShader from "./shaders/studio/fragmentShader.glsl";
import {
  splatterConfig,
  longSleeveConfig,
  poloConfig,
} from "./assets/clothingConfig";
import collectionStore from "../stores/collectionStore";

export default function Studio(props) {
  const { nodes } = useGLTF("/models/studio-29okt.glb");

  const [hoveredItem, setHoveredItem] = useState({ type: null, id: null });
  const [vec] = useState(() => new THREE.Vector3());
  const [lookVec] = useState(() => new THREE.Vector3()); // Separate vector for lookAt

  const [effectsEnabled, setEffectsEnabled] = useState(true);
  const [blendFunction, setBlendFunction] = useState(BlendFunction.MULTIPLY);

  useControls("Effects", {
    enableEffects: {
      value: effectsEnabled,
      onChange: (value) => setEffectsEnabled(value),
    },
    blendFunction: {
      value: blendFunction,
      options: Object.keys(BlendFunction).reduce((acc, key) => {
        acc[key] = BlendFunction[key];
        return acc;
      }, {}),
      onChange: (value) => setBlendFunction(value),
    },
  });

  const { camera, mouse } = useThree();

  const cameraPositions = {
    polo: {
      x: 0,
      y: -0.5,
      z: -0.4,
      lookAt: [5, -2, -5],
    },
    longsleeve: {
      x: -1,
      y: -0.8,
      z: -1.2,
      lookAt: [4, -1, -7],
    },
    splatter: {
      x: 0.2,
      z: -0.7,
      y: -0.2,
      lookAt: [-1, -1, -2],
    },
  };

  const handlePointerOver = (type, id) => {
    setHoveredItem({ type, id });
    document.body.style.cursor = "pointer";
  };

  const handlePointerOut = () => {
    setHoveredItem({ type: null, id: null });
    document.body.style.cursor = "auto";
  };

  const bakedFinalTexture = useLoader(THREE.TextureLoader, "/assets/baked.jpg");
  bakedFinalTexture.colorSpace = THREE.SRGBColorSpace;
  bakedFinalTexture.flipY = false;

  const studioMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uBakedDayTexture: new THREE.Uniform(bakedFinalTexture),
    },
    vertexShader,
    fragmentShader,
    side: THREE.DoubleSide,
  });

  const { setSidebarOpen, setSidebarClose } = collectionStore();
  const sidebarOpen = collectionStore((state) => state.sidebarOpen);
  const cameraPosition = collectionStore((state) => state.cameraPosition);

  /* Camera Controls */
  const [targetPosition, setTargetPosition] = useState(null);
  const [lookAtTarget, setLookAtTarget] = useState(null);

  const [initialPosition, setInitialPosition] = useState(null);
  const [initialLookAt, setInitialLookAt] = useState(null);

  const setSelectedCollection = collectionStore(
    (state) => state.setSelectedCollection
  );
  const setProductHandle = collectionStore((state) => state.setProductHandle);

  const handleCollectionClick = (type) => {
    const position = cameraPositions[type];
    if (position) {
      setInitialPosition(camera.position.clone());
      setInitialLookAt(lookVec.clone());
      setTargetPosition(position);
      setLookAtTarget(position.lookAt);
      setSelectedCollection(type);
      setProductHandle(type);
    }
    setTimeout(() => {
      setSidebarOpen(true);
    }, 1000);
  };

  const introScreen = collectionStore((state) => state.introScreen);

  useFrame(() => {
    if (targetPosition) {
      // Smoothly move the camera to the target position
      camera.position.lerp(
        vec.set(targetPosition.x, targetPosition.y, targetPosition.z),
        0.04
      );
      if (lookAtTarget) {
        // Make the camera look at the specified target (separate vector)
        camera.lookAt(lookVec.lerp(new THREE.Vector3(...lookAtTarget), 0.01));
      }
    } else {
      // Default behavior for mouse-controlled camera movement
      camera.position.lerp(vec.set(mouse.x * 0.4, mouse.y * 0.1, 5), 0.05);
    }
  });

  useEffect(() => {
    if (!sidebarOpen) {
      // Return the camera to the original position when the sidebar is closed
      setTargetPosition({ x: mouse.x * 0.4, y: mouse.y * 0.1, z: 5 });
      setLookAtTarget([0, 0, 0]);
    }
  }, [sidebarOpen]);

  const splatterMesh = useRef();
  const longsleeveMesh = useRef();
  const poloMesh = useRef();

  return (
    <group {...props} dispose={null} rotation={[0, -Math.PI / 2, 0]} layers={1}>
      <mesh
        name="studio"
        geometry={nodes.studio.geometry}
        material={studioMaterial}
        position={[0, 1.5, 0]}
        rotation={[Math.PI / 2, 0, -Math.PI / 2]}
        scale={1.916}
      />

      <Selection>
        <Select enabled={hoveredItem.type === "splatter"}>
          <group
            onPointerOver={() => handlePointerOver("splatter")}
            onPointerOut={handlePointerOut}
            onClick={() => handleCollectionClick("splatter")}
          >
            {splatterConfig.map(({ color, position, rotation }, index) => (
              <mesh
                key={index}
                geometry={nodes[`Splatter_${color}`].geometry}
                material={studioMaterial}
                position={position}
                rotation={rotation}
                scale={1.916}
                ref={splatterMesh}
              />
            ))}
          </group>
        </Select>
        <Select enabled={hoveredItem.type === "longsleeve"}>
          <group
            onPointerOver={() => handlePointerOver("longsleeve")}
            onPointerOut={handlePointerOut}
            onClick={() => handleCollectionClick("longsleeve")}
          >
            {longSleeveConfig.map(
              ({ color, position, rotation, scale }, index) => (
                <mesh
                  key={index}
                  geometry={nodes[`Longsleeve_${color}`].geometry}
                  material={studioMaterial}
                  position={position}
                  rotation={rotation}
                  scale={scale}
                  ref={longsleeveMesh}
                />
              )
            )}
          </group>
        </Select>
        <Select enabled={hoveredItem.type === "polo"}>
          <group
            onPointerOver={() => handlePointerOver("polo")}
            onPointerOut={handlePointerOut}
            onClick={() => handleCollectionClick("polo")}
          >
            {poloConfig.map(({ color, position, rotation, scale }, index) => (
              <mesh
                key={index}
                geometry={nodes[`Polo_${color}`].geometry}
                material={studioMaterial}
                position={position}
                rotation={rotation}
                scale={scale}
                ref={poloMesh}
              ></mesh>
            ))}
          </group>
        </Select>
        {effectsEnabled && (
          <Effects
            blendFunction={blendFunction}
            hoveredItem={hoveredItem}
            targetMeshes={[splatterMesh, longsleeveMesh, poloMesh]}
          />
        )}
      </Selection>
    </group>
  );
}

useGLTF.preload("/models/studio-29okt.glb");
